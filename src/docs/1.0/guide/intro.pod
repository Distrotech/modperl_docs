=head1 NAME

Introduction. Incentives.

=head1 Description

An introduction to what mod_perl is all about, its different features,
and some explanations of C<Apache::Registry>, C<Apache::PerlRun> and
the Apache/Perl API.


=head1 What is mod_perl

The Apache/Perl integration project brings together the full power of
the Perl programming language and the Apache HTTP server. With
mod_perl it is possible to write Apache modules entirely in Perl,
letting you easily do things that are more difficult or impossible in
regular CGI programs, such as running sub requests. In addition, the
persistent Perl interpreter embedded in the server saves the overhead
of starting an external interpreter, i.e. the penalty of Perl start-up
time.  And not the least important feature is code caching, where
modules and scripts are loaded and compiled only once, and for the
rest of the server's life they are served from the cache. Thus the
server spends its time only running already loaded and compiled code,
which is very fast.

The primary advantages of mod_perl are power and speed. You have full
access to the inner workings of the web server and can intervene at
any stage of request-processing. This allows for customized processing
of (to name just a few of the phases) URI-E<gt>filename translation,
authentication, response generation, and logging. There is very little
run-time overhead. In particular, it is not necessary to start a
separate process, as is often done with web-server extensions. The
most wide-spread such extension, the Common Gateway Interface (CGI),
can be replaced entirely with Perl code that handles the response
generation phase of request processing.  mod_perl includes two general
purpose modules for this purpose: C<Apache::Registry>, which can
transparently run existing perl CGI scripts and C<Apache::PerlRun>,
which does a similar job but allows you to run "dirtier" (to some
extent) scripts.

You can configure your httpd server and handlers in Perl (using
C<PerlSetVar>, and E<lt>PerlE<gt> sections). You can even define your
own configuration directives.

Many people ask "How much of a performance improvement does mod_perl
give?" Well, it all depends on what you are doing with mod_perl and
possibly who you ask. Developers report speed boosts from 200% to
2000%. The best way to measure is to try it and see for yourself! (See
http://perl.apache.org/tidbits.html and
http://perl.apache.org/stories/ for the facts.)

=head2 mod_cgi

When you run your CGI scripts by using a configuration like this:

  ScriptAlias /cgi-bin/ /home/httpd/cgi-bin/

you run it under a mod_cgi handler, you never define it
explicitly. Apache does all the configuration work behind the scenes,
when you use a ScriptAlias.

By the way, don't confuse C<ScriptAlias> with the C<ExecCGI>
configuration option, which we enable so that the script will be
executed rather than returned as a plain text file. For example for
mod_perl and C<Apache::Registry> you would use a configuration like:

  <Location /perl>
    SetHandler perl-script
    PerlHandler Apache::Registry
    Options ExecCGI
    PerlSendHeader On
  </Location>

=head2 C API

META: complete

=head2 Perl API

META: complete

=head2 Apache::Registry

From the viewpoint of the Perl API, C<Apache::Registry> is simply
another handler that's not conceptually different from any other
handler. C<Apache::Registry> reads in the script file, compiles,
executes it and stores into the cache.  Since the perl interpreter
keeps running from child process' creation to its death, any code
compiled by the interpreter is kept in memory until the child dies.

To prevent script name collisions, C<Apache::Registry> creates a
unique key for each cached script by prepending C<Apache::ROOT::> to
the mangled path of the script's URI.  This key is actually the
package name that the script resides in. So if you have requested a
script C</perl/project/test.pl>, the scripts would be wrapped in code
which starts with a package declaration of:

  package Apache::ROOT::perl::project::test_e2pl;

C<Apache::Registry> also stores the script's last modification time.
Everytime the script changes, the cached code is discarded and
recompiled using the modified source. However, it doesn't check the
modification times of any of the perl libraries the script might use.

C<Apache::Registry> overrides C<CORE::exit()> with C<Apache::exit()>,
so CGI scripts that use C<exit()> will run correctly. We will talk
about all these details in depth later.

The last thing C<Apache::Registry> does, is emulation of mod_cgi's
environment variables, like C<$ENV{SERVER_NAME}>, C<$ENV{REMOTE_USER}>
and so on. B<PerlSetupEnv Off> disables this feature which saves some
memory and CPU cycles.

From the viewpoint of the programmer, there is almost no difference
between running a script as a plain CGI script under mod_cgi and
running it under mod_perl.  There is however a great speed
improvement, but at the expense of much heavier memory usage (there is
no free lunch :).

When they run under  mod_cgi, your CGI scripts are loaded each time 
they are called and then they exit.  Under mod_perl they are loaded 
once and cached.  This gives a big performance boost.  But because the
code is cached and doesn't exit, it won't cleanup memory as it would
under mod_cgi.  This can have unexpected effects.

Your scripts will be recompiled and reloaded by mod_perl when
it detects that you have changed them, but remember that any 
libraries that your scripts might require() or use() will not 
be recompiled when they are changed.  You will have to take
action yourself to ensure that they are recompiled.

Of course the guide will answer all these issues in depth.

Let's see what happens to your script when it's being executed under
C<Apache::Registry>. If we take the simplest code of (URI
C</perl/project/test.pl>)

  print "Content-type: text/html\n\n";
  print "It works\n";

C<Apache::Registry> will convert it into the following:

  package Apache::ROOT::perl::project::test_e2pl;
  use Apache qw(exit);
  sub handler {
    print "Content-type: text/html\n\n";
    print "It works\n";
  }

The first line provides a unique namespace for the code to use, and a
unique key by which the code can be referenced from the cache.

The second line imports C<Apache::exit> which over-rides perl's
built-in C<exit>.

The C<sub handler> subroutine is wrapped around your code. By default
(i.e. if you do not specify an alternative), when you use mod_perl and
your code's URI is called, mod_perl will seek to execute the URI's
associated C<handler> subroutine.

META: Complete

=head2 Apache::PerlRun

META: Complete

=head1 What will you learn

This document was written in an effort to help you start using
Apache's mod_perl extension as quickly and easily as possible. It
includes information about the installation and configuration of both
Perl and the Apache web server and delves deeply into the issues of
writing and porting existing Perl scripts to run under mod_perl. Note
that it does not attempt to enter the big world of using the Perl API
or C API.  You will find pointers to coverage of these topics in the
L<Getting Help and Further Learning|guide::help/> section of this
document. This guide tries to cover the most of the
C<Apache::Registry> and C<Apache::PerlRun> modules. Along with
mod_perl related topics, there are many more issues related to
administering Apache servers, debugging scripts, using databases,
mod_perl related Perl, code snippets and more.

It is assumed that you know at least the basics of building and
installing Perl and Apache. (If you do not, just read the INSTALL
documents which are part of the distribution of each package.)
However, in this guide you will find specific Perl and Apache
installation and configuration notes, which will help you successfully
complete the mod_perl installation and get the server running in a
short time.

If after reading this guide and the other documents listed in
L<Getting Help and Further Learning|guide::help/> you feel that your
questions remain unanswered, you could try asking the apache/mod_perl
mailing list to help you.  But first try to browse the mailing list
archive (located at http://mathforum.org/epigone/modperl ). Often you
will find the answer to your question by searching the mailing list
archive, since most questions have already been asked and answered
already!  If you ignore this advice, do not be surprised if your
question goes unanswered - it bores people when they're asked to
answer the same question repeatedly - especially if the answer can be
found in the archive or in the documentation.  This does not mean that
you should avoid asking questions, just do not abuse the available
help and B<RTFM> before you call for B<HELP>. (You have certainly
heard the infamous fable of the shepherd boy and the wolves...) And if
you do ask questions on the mailing list I<please> make your subject
line descriptive of the problem, not just "Help" - you're far more
likely to get replies if people can see the issue you are talking
about straight away.

If you find incorrect details or mistakes in my grammar, or you want 
to contribute to this document please feel free to send me an email at
stas@stason.org .

=head1 Maintainers

Maintainer is the person(s) you should contact with updates,
corrections and patches.

=over

=item *

Stas Bekman E<lt>stas (at) stason.orgE<gt>

=back


=head1 Authors

=over

=item *

Stas Bekman E<lt>stas (at) stason.orgE<gt>

=back

Only the major authors are listed above. For contributors see the
Changes file.


=cut
