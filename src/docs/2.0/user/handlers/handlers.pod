=head1 NAME

Using Perl*Handlers

=head1 Description

This chapter discusses C<Perl*Handler>s and presents examples of their
use.


META: need to add/correct a diagram similar to the one in the eagle
book, presenting the order of the phases.

                           |
                           v
         -------------->[wait]---->post-read-request 
         |                              |
         |                              v
         |                        URI translation
         |                              |
         |                              v
         |                         header parsing
         |                              |
         |                              v
         |                         access control
         |     <REQUEST LOOP>           |
      cleanup                           v
         |                         authentication
         |                              |
         |                              v
         |                          authorization
         |                              |
         |                              v
         |                        MIME type checking
         |                              |
         |                              v
      logging <----- RESPONSE <------ fixups




=head1 Handlers (Hooks) Types

For each phase there can be more than one handler assigned (also known
as I<hooks>, because the C functions are called
I<ap_hook_E<lt>phase_nameE<gt>>). The following types specify a
phase's behavior when there is more then one handler to run for this
phase. (For C API declarations see I<include/ap_config.h>, which
includes other types which aren't exposed by mod_perl.)

=over

=item * VOID

Handlers of the type C<VOID> will be I<all> executed in the order they
have been registered disregarding their return values. Though in
mod_perl they are expected to return C<Apache::OK>.

=item * RUN_FIRST

Handlers of the type C<RUN_FIRST> will be executed in the order they
have been registered until the first handler that returns something
other than C<Apache::DECLINED>. If the return value is
C<Apache::DECLINED>, the next handler in the chain will be run. If the
return value is C<Apache::OK> the next phase will start. In all other
cases the execution will be aborted.

=item * RUN_ALL

Handlers of the type C<RUN_ALL> will be executed in the order they
have been registered until the first handler that returns something
other than C<Apache::OK> or C<Apache::DECLINED>.

=back

Also see L<mod_perl Directives Argument Types and Allowed
Location|user::config::config/mod_perl_Directives_Argument_Types_and_Allowed_Location>

=head1 Hook Ordering (Position)

The following constants specify how the new hooks (handlers) are
inserted into the list of hooks when there is at least one hook
already registered for the same phase.

META: need to verify the following:

=over

=item *  C<APR::HOOK_REALLY_FIRST>

run this hook first, before ANYTHING.

=item *  C<APR::HOOK_FIRST>

run this hook first.

=item *  C<APR::HOOK_MIDDLE>

run this hook somewhere.

=item *  C<APR::HOOK_LAST>

run this hook after every other hook which is defined.

=item *  C<APR::HOOK_REALLY_LAST>

run this hook last, after EVERYTHING.

=back

META: more information in mod_example.c talking about
position/predecessors, etc.

=head1 Server Configuration (Startup) Phases

=head2 PerlOpenLogsHandler

The I<open_logs> phase happens just before the I<post_config> phase.

Handlers registered by C<PerlOpenLogsHandler> are usually used for
opening module-specific log files.

At this stage the C<STDERR> stream is not yet redirected to
I<error_log>, and therefore any messages to that stream will be
printed to the console the server is starting from (if such exists).

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<SRV>.

For example here is the C<Apache::OpenLogs> handler that opens a
custom log file:

  file:Apache/OpenLogs.pm
  -----------------------
  package Apache::OpenLogs;
  
  use strict;
  
  use File::Spec::Functions;
  
  my $log_file = catfile "logs", "mylog";
  
  sub handler {
      my ($conf_pool, $log_pool, $temp_pool, $s) = @_;
      my $log_path = Apache::server_root_relative($conf_pool, $log_file);
      $s->warn("opening the log file: $log_path");
      open my $log, ">>$log_path" or die "can't open $log_path: $!";
      return Apache::OK;
  }
  1;

The I<open_logs> phase handlers accept four arguments: the
configuration pool, the logging streams pool, the temporary pool and
the server object. In our example the handler uses the function
C<Apache::server_root_relative()> to set the full path to the log
file, which is then opened. Of course in the real world handlers the
module needs to be extended to provide an accessor that can write to
this log file.

To configure this handler add to I<httpd.conf>:

  PerlOpenLogsHandler Apache::OpenLogs



=head2 PerlPostConfigHandler

The I<post_config> phase happens right after Apache has processed the
configuration files, before any child processes were spawned (which
happens at the I<child_init> phase).

This phase can be used for initializing things to be shared between
all child processes. You can do the same in the startup file, but in
the I<post_config> phase you have an access to a complete
configuration tree.

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<SRV>.

Example:






=head2 PerlChildInitHandler

META: PerlChildExitHandler?

The I<child_init> phase happens immediately after the child process is
spawned. Each child process will run the hooks of this phase only once
in their life-time.

In the prefork MPM this phase is useful for pre-opening database
connections (similar to Apache::DBI in mod_perl 1.0).

This phase is of type C<VOID>.

The handler's configuration scope is C<SRV>.

Example:








=head1 Command (Protocol) Phases

Since Apache 2.0 makes it possible to implement other than HTTP
protocols, the connection phases were added. The standard HTTP
handlers normally don't need need these phases, since HTTP is already
handled by the request phases. Therefore these phases are used mostly
for the implementation of non-HTTP protocol implementations.

=head2 PerlPreConnectionHandler

The I<pre_connection> phase happens just after the server accepts the
connection, but before it is handed off to a protocol module to be
served.  It gives modules an opportunity to modify the connection as
soon as possible. The core server uses this phase to setup the
connection record based on the type of connection that is being used.

In mod_perl 1.0 during code development C<Apache::Reload> was used to
automatically reload modified since the last request Perl modules. It
was invoked during C<post_read_request>, the first HTTP request's
phase. In mod_perl 2.0 I<pre_connection> is the earliest phase, so if
we want to make sure that all modified Perl modules are reloaded for
any protocols and its phases, it's the best to set the scope of the
Perl interpreter to the lifetime of the connection and invoke the
C<Apache::Reload> handler during the I<pre_connection> phase. However
this development-time advantage can become a disadvantage in
production--for example if a connection, handled by HTTP protocol, is
configured as C<KeepAlive> and there are several requests coming on
the same connection and only one handled by mod_perl and the others by
the default images handler, the Perl interpreter won't be available to
other threads while the images are being served.

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<SRV>, because it's not known
yet which resource the request will be mapped to.




Example:

A I<pre_connection> handler accepts connection record and socket
objects as its arguments:

  sub handler {
      my ($c, $socket) = @_;
      # ...
      return Apache::OK;
  }

=head2 PerlProcessConnectionHandler

The I<process_connection> phase is used to actually process the
connection that was received.  Only protocol modules should assign
handlers for this phase, as it gives them an opportunity to replace
the standard HTTP processing with processing for some other protocols
(e.g., POP3, FTP, etc.).

This phase is of type C<RUN_FIRST>.

The handler's configuration scope is C<SRV>. Therefore the only way to
run protocol servers different than the core HTTP is inside dedicated
virtual hosts.

Example:

META: echo example comes here

A I<process_connection> handler accepts a connection record object as
its only argument, a socket object can be retrieved from the
connection record object.

  sub handler {
      my ($c) = @_;
      my $socket = $c->client_socket;
      # ...
      return Apache::OK;
  }

META: the echo example doesn't work with filter, because it reads and
writes directly from/to the socket. Here comes the echo_filter
example.  But may be echo is not so good, use something like
eliza/'lc' to show the retrieval of the data, here is some eliza
protocol code plus an output lc filter.

  package Apache::Eliza2;
  
  use strict;
  use warnings FATAL => 'all';
  
  use Apache::Connection ();
  use APR::Bucket ();
  use APR::Brigade ();
  use APR::Util ();
  
  require Chatbot::Eliza;
  
  use APR::Const -compile => qw(SUCCESS EOF);
  use Apache::Const -compile => qw(OK MODE_GETLINE);
  
  my $eliza = new Chatbot::Eliza;
  
  sub handler {
      my Apache::Connection $c = shift;
  
      my $bb_in  = APR::Brigade->new($c->pool, $c->bucket_alloc);
      my $bb_out = APR::Brigade->new($c->pool, $c->bucket_alloc);
      my $last = 0;
  
      while (1) {
          my $rv = $c->input_filters->get_brigade($bb_in, Apache::MODE_GETLINE);
  
          if ($rv != APR::SUCCESS or $bb_in->empty) {
              my $error = APR::strerror($rv);
              unless ($rv == APR::EOF) {
                  warn "[eliza] get_brigade: $error\n";
              }
              $bb_in->destroy;
              last;
          }
  
          while (!$bb_in->empty) {
              my $bucket = $bb_in->first;
  
              $bucket->remove;
  
              if ($bucket->is_eos) {
                  $bb_out->insert_tail($bucket);
                  last;
              }
  
              my $data;
              my $status = $bucket->read($data);
              return $status unless $status == APR::SUCCESS;
  
              if ($data) {
                  $data =~ s/[\r\n]*$//;
                  $last++ if $data =~ /good bye/i;
                  $data = $eliza->transform( $data ) . "\n\n";
                  $bucket = APR::Bucket->new($data);
              }
  
              $bb_out->insert_tail($bucket);
          }
  
          my $b = APR::Bucket::flush_create($c->bucket_alloc);
          $bb_out->insert_tail($b);
          $c->output_filters->pass_brigade($bb_out);
          last if $last;
      }
  
      Apache::OK;
  }
  
  use base qw(Apache::Filter);
  use constant BUFF_LEN => 1024;
  
  sub lowercase : FilterConnectionHandler {
      my $filter = shift;
    
      while ($filter->read(my $buffer, BUFF_LEN)) {
          $filter->print(lc $buffer);
      }
    
      return Apache::OK;
  }
  
  1;


=head1 HTTP Request Phases

Each HTTP request is processes by 11 phases at most, executed in the
following order:

=over

=item 1 PerlPostReadRequestHandler (PerlInitHandler)

=item 2 PerlTransHandler

=item 3 PerlHeaderParserHandler (PerlInitHandler)

=item 4 PerlAccessHandler

=item 5 PerlAuthenHandler

=item 6 PerlAuthzHandler

=item 7 PerlTypeHandler

=item 8 PerlFixupHandler

=item 9 PerlResponseHandler

=item 10 PerlLogHandler

=item 11 PerlCleanupHandler

=back

=head2 PerlPostReadRequestHandler

The I<post_read_request> phase is the first request phase and happens
immediately after the request has been read and HTTP headers were
parsed.

This phase is usually used to do processings that must happen once per
request.

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<SRV>, because at this phase the
request has not yet been associated with a particular filename or
directory.

Example:

=head2 PerlTransHandler

The I<translate> phase provides an opportunity to translate the
request's URI into an corresponding filename.

In addition to doing the translation, this stage can be used to modify
the URI itself and the request method. This is also a good place to
register new handlers for the following phases based on the URI.

If no custom handlers is provided, the server's default rules
(C<Alias> directives and the like) will continue to be followed.

This phase is of type C<RUN_FIRST>.

The handler's configuration scope is C<SRV>, because at this phase the
request has not yet been associated with a particular filename or
directory.

Example:


=head2 PerlInitHandler

When configured inside any section, but C<E<lt>VirtualHostE<gt>> this
handler is an alias for C<L<PerlHeaderParserHandler>> described later.
Otherwise it acts as an alias for C<L<PerlPostReadRequestHandler>>
descibed earlier.

It is the first handler to be invoked when serving a request.

This phase is of type C<RUN_ALL>.

Example:




=head2 PerlHeaderParserHandler

The I<header_parser> phase is the first phase to happen after the
request has been mapped to its C<E<lt>LocationE<gt>> (or
equivalent). At this phase the handler can examine the request headers
and to take a special action based on these. For example this phase
can be used to block evil clients, while little resources were wasted
on these.

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<DIR>.

Example:




=head2 PerlAccessHandler

The I<access_checker> phase is the first of three handlers that are
involved in authentication and authorization, and used for access
control.

This phase can be used to restrict access from a certain IP address,
time of the day or any other rule not connected to the user's
identity.

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<DIR>.

Example:


=head2 PerlAuthenHandler

The I<check_user_id> (I<authen>) phase is called whenever the
requested file or directory is password protected.  This, in turn,
requires that the directory be associated with C<AuthName>,
C<AuthType> and at least one C<require> directive.

This phase is usually used to verify a user's identification
credentials. If the credentials are verified to be correct, the
handler should return C<OK>.  Otherwise the handler returns
C<AUTH_REQUIRED> to indicate that the user has not authenticated
successfully.  When Apache sends the HTTP header with this code, the
browser will normally pop up a dialog box that prompts the user for
login information.

This phase is of type C<RUN_FIRST>.

The handler's configuration scope is C<DIR>.

=head2 PerlAuthzHandler

The I<auth_checker> (I<authz>) phase is used for authorization
control. This phase requires a successful authentication from the
previous phase, because a username is needed in order to decide
whether a user is authorized to access the requested resource.

As this phase is tightly connected to the authentication phase, the
handlers registered for this phase are only called when the requested
resource is password protected, similar to the auth phase. The handler
is expected to return C<DECLINED> to defer the decision, C<OK> to
indicate its acceptance of the user's authorization, or
C<AUTH_REQUIRED> to indicate that the user is not authorized to access
the requested document.

This phase is of type C<RUN_FIRST>.

The handler's configuration scope is C<DIR>.

Example:


=head2 PerlTypeHandler

The I<type_checker> phase is used to set the response MIME type
(C<Content-type>) and sometimes other bits of document type
information like the document language.

For example C<mod_autoindex>, which performs automatic directory
indexing, uses this phase to map the filename extensions to the
corresponding icons which will be later used in the listing of files.

Of course later phases may override the mime type set in this phase.

This phase is of type C<RUN_FIRST>.

The handler's configuration scope is C<DIR>.

Example:



=head2 PerlFixupHandler

The I<fixups> phase is happening just before the content handling
phase. It gives the last chance to do things before the response is
generated. For example in this phase C<mod_env> populates the
environment with variables configured with I<SetEnv> and I<PassEnv>
directives.

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<DIR>.

Example:


=head2 PerlResponseHandler

The I<handler> (I<response>) phase is used for generating the
response. This is probably the most important phase and most of the
existing Apache modules do most of their work at this phase.

This is the only phase that requires two directives under
mod_perl. For example:

  <Location /perl>
     SetHandler  perl-script
     PerlResponseHandler Apache::Registry
  </Location>

C<SetHandler> tells Apache that mod_perl is going to handle the
response generation. C<PerlResponseHandler> tells mod_perl which
handler is going to do the job.

This phase is of type C<RUN_FIRST>.

The handler's configuration scope is C<DIR>.

Example:



=head2 PerlLogHandler

The I<log_transaction> phase happens no matter how the previous phases
have ended up. If one of the earlier phases has aborted a request,
e.g., failed authenication or 404 (file not found) errors, the rest of
the phases up to and including the response phases are skipped. But
this phase is always executed.

By this phase all the information about the request and the response
is known, therefore the logging handlers usually record this
information in various ways (e.g., logging to a flat file or a
database).

This phase is of type C<RUN_ALL>.

The handler's configuration scope is C<DIR>.

Example:

=head2 PerlCleanupHandler

META: not implemented yet

This phase is of type C<XXX>.

The handler's configuration scope is C<XXX>.


=head1 Filtering Phases

Apache 2.0 considers all incoming and outgoing data as chunks of
information, disregarding their kind and source or storage
methods. These data chunks are stored in I<buckets>, which form
I<bucket brigades>. Both input and output filters work on these bucket
brigades and modify them if necessary.

As of this writing mod_perl provides two interfaces to filtering: a
direct mapping to buckets and bucket brigades and a simpler,
stream-oriented interface (currently available only for the output
filtering). The following examples will help to understand the
difference between the two.  The filters can do connection and request
filtering. Apache distinguish between more types, and mod_perl will
support those in the future if there will be a demand. mod_perl
handlers specify the type of the filter using the method
attributes. For example a request filter handler is declared using the
C<FilterRequestHandler> attribute:

  package Apache::InputRequestFilterFoo;
  sub handler : FilterRequestHandler {
      my($filter, $bb, $mode, $block, $readbytes) = @_;
      #...
  }
  1;

and is usually configured in the C<E<lt>LocationE<gt>> or equivalent
sections:

  <Location /input_filter>
      SetHandler modperl
      PerlResponseHandler    Apache::NiceResponse
      PerlInputFilterHandler Apache::InputRequestFilterFoo
  </Location>

And as you can guess a connection handler uses the
C<FilterConnectionHandler> attribute (this time we use the output
filter as an example):

  package Apache::OutputConnectionFilterBar;
  sub handler : FilterConnectionHandler {
      my($filter, $bb, $mode, $block, $readbytes) = @_;
      #...
  }
  1;

and configured outside the C<E<lt>LocationE<gt>> or equivalent
sections, usually within the C<E<lt>VirtualHostE<gt>> or equivalent
sections:

  Listen 8005
  <VirtualHost _default_:8005>
      ServerName localhost.localdomain:8005
   
      PerlOutputFilterHandler Apache::OutputConnectionFilterBar
      <Location />
          SetHandler modperl
          PerlResponseHandler Apache::NiceResponse
      </Location>
   
  </VirtualHost>

[META: 

Inside a connection filter the current connection object can be
retrieved with:

  my $c = $filter->c;

Inside a request filter the current request object can be retrieved
with:

  my $r = $filter->r;

This belongs to the Apache::Filter manpage and should be moved there.
]

Now let's look at the input and output filters in details.

=head2 PerlInputFilterHandler



=head2 PerlOutputFilterHandler

The C<PerlOutputFilterHandler> handler registers and configures output
filters.

This handler is of type C<VOID>.

The handler's configuration scope is C<DIR>.

The stream-orientered output filter in the following example reverses
every line of the response, preserving the new line characters in
their places:

  file:httpd.conf
  ---------------
  PerlModule Apache::ReverseFilter
  <Location /reverse>
      SetHandler modperl
      PerlResponseHandler     Apache::ReverseFilter::response
      PerlOutputFilterHandler Apache::ReverseFilter::output_filter
  </Location>

  file:Apache/ReverseFilter.pm
  ----------------------------
  package Apache::ReverseFilter;
  
  use strict;
  use warnings FATAL => 'all';
  
  use Apache::RequestRec ();
  use Apache::RequestIO ();
  use Apache::Filter ();
  
  use Apache::Const -compile => qw(OK);
  
  use constant BUFF_LEN => 1024;
  
  sub output_filter {
      my $filter = shift;
  
      while ($filter->read(my $buffer, BUFF_LEN)) {
          for (split "\n", $buffer) {
              $filter->print(scalar reverse $_);
              $filter->print("\n");
          }
      }
  
      Apache::OK;
  }
  
  sub response {
      my $r = shift;
  
      $r->content_type('text/plain');
      $r->puts(1..9, "0\n");
      $r->puts('a'..'z', "\n");
  
      Apache::OK;
  }
  1;


In this example when a request to I</reverse> is made, the response
handler C<Apache::ReverseFilter::response()> sends:

  1234567890
  abcdefghijklmnopqrstuvwxyz

as a response and the output filter handler
C<Apache::ReverseFilter::output_filter> reverses the lines, so the
client gets:

  0987654321
  zyxwvutsrqponmlkjihgfedcba

The reversing filter is quite simple: it reads from the output stream
in the I<readline()> mode in chunks up to the buffer length (1024 in
our example), and then prints each line reversed while preserving the
new line control characters at the end of each line. In order not to
distract the reader from the purpose of the example the used code is
oversimplified and won't handle correctly input lines which are longer
than 1024 characters and possibly using a different line termination
pattern. So here is an example of a more complete handler, which does
takes care of these issues:

  sub output_filter {
      my $filter = shift;
  
      my $left_over = '';
      while ($filter->read(my $buffer, BUFF_LEN)) {
          $buffer = $left_over . $buffer;
          $left_over = '';
          while ($buffer =~ /([^\r\n]*)([\r\n]*)/g) {
              $left_over = $1, last unless $2;
              $filter->print(scalar(reverse $1), $2);
          }
      }
      $filter->print(scalar reverse $left_over) if length $left_over;
  
      Apache::OK;
  }

In this handler the lines longer than the buffer's length are buffered
up in C<$left_over> and processed only when the whole line is read in,
or if there is no more input the buffered up text is flushed before
the end of the handler.






=head1 Maintainers

Maintainer is the person(s) you should contact with updates,
corrections and patches.

=over

=item *

Stas Bekman E<lt>stas (at) stason.orgE<gt>

=back


=head1 Authors

=over

=item *

=back

Only the major authors are listed above. For contributors see the
Changes file.



=cut
