=head1 NAME

Porting Apache:: Modules from mod_perl 1.0 to 2.0

=head1 Description

If you have released an C<Apache::Foo> module on CPAN you may wonder
what steps you should take to make your code working under mod_perl
2.0 while still preserving 1.0 backwards compatibility. This document
attempts to answer some of the questions related to this issue.

API changes are listed in L<the backwards compatibility
document|docs::2.0::user::compat::compat/>.

=head1 Should the Module Name Be Changed?

While you can change the name of the module, it's the best to try to
preserve the name and use some workarounds if your module cannot be
ported to run under 1.0 and 2.0 at the same time.

Most of the CPAN C<Apache::> modules for mod_perl 1.0 should work with
mod_perl 2.0 without any change. Modules including XS code may or may
not work, depending on whether they use Apache API that have changed
in Apache 2.0.

Let's say that you have a module C<Apache::Friendly> whose release
version compliant with mod_perl 1.0 is 1.57. You keep this version on
CPAN and release a new version 2.01 which is compliant with 2.0 and
preserves the name of the module. It's possible that a user may need
to have both versions of the module on the same machine. Since the two
have the same name they obviously cannot live under the same tree. One
attempt to solve that problem is to use C<MP_INST_APACHE2>
I<Makefile.PL>'s option. If the module is configured as:

  % perl Makefile.PL MP_INST_APACHE2=1

it'll be installed relative to the I<Apache2/> directory.

META: but of course this won't work in non-core mod_perl, since a
generic C<Makefile.PL> has no idea what to do about
MP_INST_APACHE2=1. Need to provide copy-n-paste recipe for this. Or
even add to the core a supporting module that will handle this
functionality.

The second step is to change the documentation of your 2.0 compliant
module to say:

  use Apache2 ();

in the code before the module is required or in I<startup.pl> or

  PerlModule Apache2

in I<httpd.conf>. This will C<@INC> to look in the I<Apache2/>
directory first.

The introduction of I<Apache2/> directory is similar to how Perl
installs its modules in a version specific directory. For example:

  lib/5.7.1
  lib/5.7.2

=head1 Requiring a specific mod_perl version.

To require a module to run only under 2.0, simply add:

  use Apache2;
  use mod_perl 2.0;

to your module. You can also use the variable
C<$mod_perl::VERSION>. But you should always load C<Apache2> first, so
it'll adjust C<@INC>, if mod_perl 2.0 is installed on the same base
with mod_perl 1.0.

META: Well before 2.0 is released you really have to say:

  use Apache2;
  use mod_perl 1.99;

In the configuration file you can use a special configuration "define"
symbol C<MODPERL2> which is enabled internally, as if the server had
been started with C<-DMODPERL2>.

  <IfDefine MODPERL2>
      # 2.0 configuration
  </IfDefine>
  <IfDefine !MODPERL2>
      # else
  </IfDefine>

From within Perl code this can be tested with
C<Apache::exists_config_define()>, for example:

  if (Apache::exists_config_define("MODPERL2")) {
      # some 2.0 specific code
  }

=head1 Porting mod_perl 1.0 Modules to Work with mod_perl 2.0.

The following sections will guide you through the steps of porting
your modules to mod_perl 2.0.

=head2 Figuring Out What Modules Need to be Loaded

It'd be certainly nice to have our mod_perl 1.0 code run on the
mod_perl 2.0 server unmodified. So first of all, try your luck and
test the code.

It's almost certain that your code won't work when you try, because
mod_perl 2.0 splits the functionality across many modules, and you
have to load them before the methods that live in them can be used. So
the first step is to L<figure out what these modules
are|docs::2.0::api::ModPerl::MethodLookup> and C<use()> them.

For example if we have a mod_perl 1.0 code snippet:

  $r->content_type('text/plain');
  $r->print("Hello cruel world!");

and we run it, mod_perl 2.0 will complain that the method
C<content_type> can't be found. So off we go to figure out which
module provides this method:

  % perl -MApache2 -MModPerl::MethodLookup -le \
     'print((ModPerl::MethodLookup::lookup_method(shift))[0])' \
      content_type

and we get:

  to use method 'content_type' add:
          use Apache::RequestRec ();

We copy-n-paste this snippet to our code and mod_perl doesn't complain
about this particular method anymore (of course after you've either
restarted the server or used
C<L<Apache::Reload|docs::2.0::api::Apache::Reload>>). However now it
complains about the missing C<print> method.  We know the drill, we
will use the above snippet again and add the missing module. Since we
have to repeat this procedure more than once why not defining C<L<an
alias|docs::2.0::api::ModPerl::MethodLookup/Command_Line_Lookups>> and 
then use it:

  % lookup print
  There is more than one class with method 'print'
  try one of:
        use Apache::RequestIO ();
        use Apache::Filter ();

Hmm, indeed there is more than one package that has this method. Since
we know, that we call it with the C<$r> object, it must be the
C<Apache::RequestIO> module that we are after. Indeed, loading this
module solves the problem.

The issue of picking the right module, when more than one matches, can
be resolved programmatically--
C<L<lookup_method|docs::2.0::api::ModPerl::MethodLookup/lookup_method__>>
accepts an object as an optional second argument, which is used if
there is more than one module that contains the method in
question. C<ModPerl::MethodLookup> knows that C<Apache::RequestIO>
expects an object of type C<Apache::RequestRec>, and C<Apache::Filter>
of type C<Apache::Filter>. So if we call:

  ModPerl::MethodLookup::lookup_method($r, 'print');

only one module will be matched. This functionality can be used in
C<L<AUTOLOAD|docs::2.0::api::ModPerl::MethodLookup/AUTOLOAD>>.

Now if you use a wide range of used APIs, the process of finding all
the modules that need to be loaded can be quite frustrating. In that
case you may find the function
C<L<preload_modules()|docs::2.0::api::ModPerl::MethodLookup/preload_all_modules__>>
to be right pill. This function preloads B<all> mod_perl 2.0 modules,
implementing their API in XS. However before going in production, you
should consider removing the call to this function and to load only
the modules that are used, in order to save memory. CPAN module
developers in no way should be tempted to call this function from
their modules, because it prevents from the user of their module to
optimize the memory usage.

=head2 Handling Missing and Modified mod_perl 1.0 APIs

mod_perl 2.0 had to modify or remove certain APIs to adhere to the
substantial changes the Apache C API went through. It wasn't core
developers desire to break the API, but simply there was no other
choice.  If you figure out that some method is reported missing and
can't be found using
L<ModPerl::MethodLookup|/Figuring_Out_What_Modules_Need_to_be_Loaded>,
chances are that this method doesn't exist in mod_perl 2.0 API. Also
it's possible that the method exists, but it still doesn't work, since
its prototype has been changed (e.g., some functions now require a
pool object). Instead of guessing, refer to L<the backwards
compatibility
document|docs::2.0::user::compat::compat/> to learn which APIs were
modified or removed.

If the code includes methods whose API have been changed or these
methods no longer exist, you have to options:

=over

=item 1

Port your code to use the mod_perl 2.0 API.

=item 2

Use the C<L<Apache::compat|docs::2.0::api::Apache::compat>> module.

=back

If you need to have your code working with both mod_perl versions,
which is the case for CPAN module writers who wish to continue to
maintain a single code base, rather than supplying two separate
implementations, the variable C<$mod_perl::VERSION> should be used.

For example, the method C<send_http_header> doesn't exist in mod_perl
2.0 API. Therefore our code that is supposed to work under both
mod_perl versions may look like this:

  use mod_perl;
  use constant MP2 => ($mod_perl::VERSION >= 1.99);
  ...
  sub handler {
      my $r = shift;
      $r->content_type('text/html');
      $r->send_http_header() unless MP2;
      ...
  }

The C<L<Apache::compat|docs::2.0::api::Apache::compat>> module tries
to hide the changes in API prototypes and implement the removed
methods and functions. However it does that in pure Perl, so things
are going to be slower. This module is useful for the transition
stage, but you are better off to port your code to use the mod_perl
2.0 API.

It's especially important to repeat that C<L<CPAN module developers are
requested not to use this module in their
code|docs::2.0::api::Apache::compat/Use_in_CPAN_Modules>>, since it takes the control over
performance away from users.

However the C<L<Apache::compat|docs::2.0::api::Apache::compat>> module
is also useful to learn how the API have been changed. Simply look at
the source code and see how it should be implemented in mod_perl 2.0.
For example mod_perl 2.0 doesn't provide the C<Apache-E<gt>gensym>
method. If we look at the C<Apache/compat.pm> source, we can see that
it loads the module C<Symbol> and calls its C<gensym()> function
instead. mod_perl 2.0 works with Perl versions 5.6 and higher, and
C<Symbol.pm> is included in the core distribution since that version,
so was no reason to keep providing C<Apache-E<>gensym>. So if the
original code looked as:

  my $fh = Apache->gensym;
  open $fh, $file or die "Can't open $file: $!";

in order to port it mod_perl 2.0 we can write:

  use mod_perl;
  use constant MP2 => ($mod_perl::VERSION >= 1.99);
  ...
  require Symbol if MP2;
  ...
  
  my $fh = MP2 ? Symbol::gensym : Apache->gensym;
  open $fh, $file or die "Can't open $file: $!";

If we don't need to keep the backwards compatibility with mod_perl
1.0, we don't even have to use the C<Symbol> module, since under Perl
version 5.6 and higher we can just do:

  open my $fh, $file or die "Can't open $file: $!";


=head2 Porting XS Code and Makefile.PL

If your module's XS code relies on Apache and mod_perl C APIs, it's
very likely that you will have to adjust the XS code to the Apache 2.0
and mod_perl 2.0 C API.

The C API has changed a lot, so chances are that you are much better
off not to mix the two APIs in the same XS file. However if you do
want to mix the two you will have to use something like the following:

  #include ap_mmn.h
  /* ... */
  #if AP_MODULE_MAGIC_AT_LEAST(20020329,1)
      /* 2.0 code */
  #else
      /* 1.0 code */
  #endif

The C<20020329.1> is the value of the magic version number matching
Apache 2.0.36, the earliest Apache version supported by mod_perl 2.0.

As for porting I<Makefile.PL>, it's only an issue if it was using
C<Apache::src>. A new configuration system is in works. So watch this
space for updates on this issue.

META: ModPerl::MM is a likely candidate for the new replacement of
Apache::src


=head1 Thread Safety

META: to be written

  #ifdef MP_THREADED
      /* threads specific code goes here */
  #endif

For now see: http://httpd.apache.org/docs-2.0/developer/thread_safety.html


=head1 PerlIO

PerlIO layer has become usable only in perl 5.8.0, so if you plan on
working with PerlIO, you can use the C<PERLIO_LAYERS> constant. e.g.:

  #ifdef PERLIO_LAYERS
  #include "perliol.h"
  #else 
  #include "iperlsys.h"
  #endif


=head1 'make test' Suite

C<Apache::Test> testing framework that comes together with mod_perl
2.0 works with 1.0 and 2.0 mod_perl versions. Therefore you should
consider porting your test suite to use L<the Apache::Test
Framework|docs::general::testing::testing>.

=head1 Apache C Code Specific Notes

=head2 Apache Core Documentation

Most of documentation dedicated for migration to Apache 2.0 can be
found at: http://httpd.apache.org/docs-2.0/developer/

The Apache 2.0 API documentation now resides in the C header files,
which can be conveniently browsed via http://docx.webperf.org/.

The APR API documentation can be found here http://apr.apache.org/.

The new Apache and APR APIs include many new functions. Though certain
functions have been preserved, either as is or with a changed
prototype (for example to work with pools), others have been
renamed. So if you are porting your code and the function that you've
used doesn't seem to exist in Apache 2.0, first refer to the "compat"
header files, such as: I<include/ap_compat.h>,
I<srclib/apr/include/apr_compat.h>, and
I<srclib/apr-util/include/apu_compat.h>, which list functions whose
names have changed but which are otherwise the same. If failed,
proceed to look in other headers files in the following directories:

=over

=item *

I<ap_> functions in I<include/>

=item *

I<apr_> functions in I<srclib/apr/include/> and
I<srclib/apr-util/include/>

=back


=head2 ap_soft_timeout(), ap_reset_timeout(), ap_hard_timeout() and ap_kill_timeout()

If the C part of the module in 1.0 includes C<ap_soft_timeout()>,
C<ap_reset_timeout()>, C<ap_hard_timeout()> and C<ap_kill_timeout()>
functions simply remove these in 2.0. There is no replacement for
these functions because Apache 2.0 uses non-blocking I/O.  As a
side-effect of this change, Apache 2.0 no longer uses C<SIGALRM>,
which has caused conflicts in mod_perl 1.0.


=head1 Maintainers

Maintainer is the person(s) you should contact with updates,
corrections and patches.

Stas Bekman E<lt>stas (at) stason.orgE<gt>

=head1 Authors

=over 

=item *

Stas Bekman E<lt>stas (at) stason.orgE<gt>

=item *

Doug MacEachern E<lt>dougm (at) covalent.netE<gt>

=back

Only the major authors are listed above. For contributors see the
Changes file.

=cut
