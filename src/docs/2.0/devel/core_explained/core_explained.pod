=head1 NAME

mod_perl 2.0 Source Code Explained

=head1 Project's Layout

In its pristine state the project is comprised of the following root
directories and files:

  Apache-Test/      - test kit for mod_perl and Apache::* modules
  ModPerl-Registry/ - ModPerl::Registry sub-project
  build/            - utilities used during project build
  docs/             - documentation
  lib/              - Perl modules
  src/              - C code that builds libmodperl.so
  t/                - mod_perl tests
  todo/             - things to be done
  util/             - useful utilities for developers
  xs/               - source xs code and maps
  Changes           - Changes file
  LICENSE           - ASF LICENSE document
  Makefile.PL       - generates all the needed Makefiles

After building the project, the following root directories and files
get generated:

  Makefile     - Makefile
  WrapXS/      - autogenerated XS code
  blib/        - ready to install version of the package

=head1 Directory src

=head2 Directory src/modules/perl/

The directory I<src/modules/perl> includes the C source files needed
to build the I<libmodperl> library.

Notice that several files in this directory are autogenerated during
the I<perl Makefile> stage.

When adding new source files to this directory you should add their
names to the C<@c_src_names> variable in I<lib/ModPerl/Code.pm>, so
they will be picked up by the autogenerated I<Makefile>.

=head1 Directory xs/

  Apache/                 - Apache specific XS code
  APR/                    - APR specific XS code
  ModPerl/                - ModPerl specific XS code
  maps/                   - 
  tables/                 - 
  Makefile.PL             - 
  modperl_xs_sv_convert.h - 
  modperl_xs_typedefs.h   - 
  modperl_xs_util.h       - 
  typemap                 - 

=head2 xs/Apache, xs/APR and xs/ModPerl

The I<xs/Apache>, I<xs/APR> and I<xs/ModPerl> directories include I<.h> files which
have C and XS code in them. They all have the I<.h> extension because
they are always C<#include-d>, never compiled into their own object
file.  and only the file that C<#include-s> an I<.h> file from these
directories should be able to see what's in there.  Anything else
belongs in a I<src/modules/perl/foo.c> public API.

=head2 xs/maps

The I<xs/maps> directory includes mapping files which describe how
Apache Perl API should be constructed and various XS typemapping.

These files get modified whenever:

=over

=item *

a new function is added or the API of the existing one is modified.

=item *

a new struct is added or the existing one is modified

=item *

a new C datatype or Perl typemap is added or an existing one is
modified.

=back

The execution of:

  % make source_scan

converts these map files into their Perl table representation in the
I<xs/tables/current/> directory. This Perl representation is then used
during C<perl Makefile.PL> to generate the XS code in the I<./WrapXS/>
directory by the xs_generate() function. This XS code is combined of
the Apache API Perl glue and mod_perl specific extensions.

Notice that I<source_scan> target is normally not run during the
project build process, since the source scanning is not stable yet,
therefore everytime the map files change, C<make source_scan> should
be run manually and the updated files ending up in the
I<xs/tables/current/> directory should be committed to the cvs
repository.

The I<source_scan> make target is actually to run
I<build/source_scan.pl>, which can be run directly without needing to
create I<Makefile> first.

There are three different types of map files in the I<xs/maps/>
directory:

=over

=item * Functions Mapping

  apache_functions.map
  modperl_functions.map
  apr_functions.map

=item * Structures Mapping

  apache_structures.map
  apr_structures.map

=item * Types Mapping

  apache_types.map
  apr_types.map
  modperl_types.map

=back

The following sections describe the syntax of the files in each group

=head3 Functions Mapping

The functions mapping file is comprised of groups of function
definitions. Each group starts with a header similar to XS syntax:

  MODULE=... PACKAGE=... PREFIX=... BOOT=... ISA=...

where:

=over

=item * C<MODULE>

the module name where the functions should be put.  e.g. C<MODULE
Apache::Connection> will place the functions into 
I<WrapXS/Apache/Connection.{pm,xs}>.

=item * C<PACKAGE>

the package name functions belong to, defaults to C<MODULE>.  The
value of I<guess> indicates that package name should be guessed based
on first argument found that maps to a Perl class.  If the value is
not defined and the function's name starts with I<ap_> the C<Apache>
package will be used, if it starts with I<apr_> then the C<APR>
package is used.

=item * C<PREFIX>

prefix string to be stripped from the function name.  If not specified
it defaults to C<PACKAGE>, converted to C name convention, e.g.
C<APR::Base64> makes the prefix: I<apr_base64_>.  If the converted
prefix does not match, defaults to I<ap_> or I<apr_>.

=item * C<BOOT>

The C<BOOT> directive tells the XS generator, whether to add the boot
function to the autogenerated XS file or not. If the value of C<BOOT>
is not true or it's simply not declared, the boot function won't be
added.

If the value is true, a boot function will be added to the XS file.
Note, that this function is not declared in the map file.

The boot function name must be constructed from three parts:

  'mpxs_' . MODULE . '_BOOT'

where C<MODULE> is the one declared with C<MODULE=> in the map file.

For example if we want to have an XS boot function for a class
C<APR::IO>, we create this function in I<xs/APR/IO/APR__IO.h>:

  static void mpxs_APR__IO_BOOT(pTHX)
  {
     /* boot code here */
  }

and now we add the C<BOOT=1> declaration to the
I<xs/maps/modperl_functions.map> file:

  MODULE=APR::IO PACKAGE=APR::IO BOOT=1

When I<make xs_generate> is run (after running I<make source_scan>),
it autogenerates I<Wrap/APR/IO/IO.xs> and amongst other things will
include:

  BOOT:
      mpxs_APR__IO_BOOT(aTHXo);


=item * C<ISA>

META: complete

=back

Every function definition is declared on a separate line (use C<\> if
the line is too long), using the following format:

  C function name | Dispatch function name | Argspec | Perl alias

where:

=over

=item * C function name

The name of the real C function.

Function names that do not begin with C</^\w/> are skipped. For
details see: C<%ModPerl::MapUtil::disabled_map>.

The return type can be specified before the C function name. It
defaults to I<return_type> in C<{Apache,ModPerl}::FunctionTable>.

META: DEFINE nuances

=item * Dispatch function name

Dispatch function name defaults to C function name. If the dispatch
name is just a prefix (I<mpxs_>, I<MPXS_>) the C function name is
appended to it.

See the explanation about function naming and arguments passing.

=item * Argspec

The argspec defaults to arguments in
C<{Apache,ModPerl}::FunctionTable>.  Argument types can be specified
to override those in the C<FunctionTable>.  Default values can be
specified, e.g. C<arg=default_value>. Argspec of C<...> indicates
I<passthru>, calling the function with C<(aTHX_ I32 items, SP **sp, SV
**MARK)>.

=item * Perl alias

the Perl alias will be created in the current C<PACKAGE>.

=back

=head3 Structures Mapping

META: complete

=head3 Types Mapping

META: complete

=head3 Modifying Maps

As explained in the beginning of this section, whenever the map file
is modified you need first to run:

  % make source_scan

Next check that the conversion to Perl tables is properly done by
verifying the resulting corresponding file in
I<xs/tables/current>. For example I<xs/maps/modperl_functions.map> is
converted into I<xs/tables/current/ModPerl/FunctionTable.pm>.

If you don't want to do a visual check on how XS code will be
generated, just rebuild the project starting with C<perl Makefile.PL
MP_GENERATE_XS=1>. Otherwise run:

  % make xs_generate

and verify that the autogenerated XS code under the I<./Wrap>
directory is correct.

=head2 XS generation process

As mentioned before XS code is generated in the I<WrapXS> directory
either during C<perl Makefile.PL> via xs_generate() if
C<MP_GENERATE_XS=1> is used or explicitly via:

  % make xs_generate

In addition it creates a number of files in the I<xs/> directory:

  modperl_xs_sv_convert.h
  modperl_xs_typedefs.h

=head1 mpxs_ vs MPXS_

If you look at the source code there are functions starting with
I<mpxs_> and those with I<MPXS_>.

If you want to mess directly with the stack (i.e. without specifying
the prototype of the function), there are two ways to do that. Either
the function has to have a prototype C<...> (which stands for
I<items>, I<MARK> and I<SP> arguments) or prefixed with I<MPXS_>,
which are hooked directly into newXS().

META: complete


=head1 MP_INLINE vs C Macros vs Normal Functions

To make the code maintainable and reusable functions and macros are
used in when programming in C (and other languages :).

When function is marked as I<inlined> it's merely a hint to the
compiler to replace the call to a function with the code inside this
function (i.e. inlined). Not every function can be inlined. Some
typical reasons why inlining is sometimes not done include:

=over

=item *

the function calls itself, that is, is recursive

=item *

the function contains loops such as C<for(;;)> or C<while()>

=item *

the function size is too large

=back

Most of the advantage of inline functions comes from avoiding the
overhead of calling an actual function. Such overhead includes saving
registers, setting up stack frames, etc. But with large functions the
overhead becomes less important.

Use the C<MP_INLINE> keyword in the declaration of the functions that
are to be inlined. The functions should be inlined when:

=over

=item *

Only ever called once (the I<wrappers> that are called from I<.xs>
files), no matter what the size of code is.

=item *

Short bodies of code called in a I<hot> code (like
I<modperl_env_hv_store>, which is called many times inside of a loop),
where it is cleaner to see the code in function form rather than macro
with lots of C<\>'s. Remember that an inline function takes much more
space than a normal functions if called from many places in the code.

=back

Of course C macros are a bit faster then inlined functions, since
there is not even I<short jump> to be made, the code is literally
copied into the place it's called from. However using macros comes at
a price:

=over

=item *

Also unlike macros, in functions argument types are checked, and
necessary conversions are performed correctly. With macros it's
possible that weird things will happen if the caller has passed
arguments of the wrong type when calling a macro.

=item *

One should be careful to pass only absolute values as I<"arguments">
to macros. Consider a macro that returns an absolute value of the
passed argument:

  #define ABS(v) ( (v) >= 0 ? (v) : -(v) )

In our example if you happen to pass a function it will be called
twice:

  abs_val = ABS(f());

Since it'll be extended as:

  abs_val = f() >= 0 ? f() : -f();

You cannot do simple operation like increment--in our example it will
be called twice:

  abs_val = ABS(i++);

Because it becomes:

  abs_val = i++ >= 0 ? i++ : -i++;

=item *

It's dangerous to use the if() condition without enclosing the code in
C<{}>, since the macro may be called from inside another if-else
condition, which may cause the else part called if the if() part from
the macro fails.

But we always use C<{}> for the code inside the if-else condition, so
it's not a problem here.

=item *

A multi-line macro can cause problems if someone uses the macro in a
context that demands a single statement.

  while (foo) MYMACRO(bar);

But again, we always enclose any code in conditional with C<{}>, so
it's not a problem for us.

=item *

Inline functions present a problem for debuggers and profilers,
because the function is expanded at the point of call and loses its
identity. This makes the debugging process a nightmare.

A compiler will typically have some option available to disable
inlining.

=back

In all other cases use normal functions.

=head1 Importing Constants and Enums into Perl API

To I<import> httpd and APR constants and enums into Perl API, edit
I<lib/Apache/ParseSource.pm>. To add a new type of C<DEFINE> constants
adjust the C<%defines_wanted> variable, for C<enums> modify
C<%enums_wanted>.

For example to import all C<DEFINE>s starting with C<APR_FLOCK_> add:

  my %defines_wanted = (
      ...
      APR => {
          ...
          flock     => [qw{APR_FLOCK_}],
          ...
      },
  );

When deciding which constants are to be exported, the regular
expression will be used, so in our example all matches
C</^APR_FLOCK_/> will be imported into the Perl API.

For example to import an I<read_type_e> C<enum> for APR, add:

  my %enums_wanted = (
      APR => { map { $_, 1 } qw(apr_read_type) },
  );

Notice that I<_e> part at the end of the enum name has gone.

After adding/modifying the datastructures make sure to run C<make
source_scan> or C<perl build/source_scan.pl> and verify that the
wanted constant or enum were picked by the source scanning
process. Simply grep I<xs/tables/current> for the wanted string. For
example after adding I<apr_read_type_e> enum we can check:

  % more xs/tables/current/Apache/ConstantsTable.pm
  ...
    'read_type' => [
      'APR_BLOCK_READ',
      'APR_NONBLOCK_READ'
    ],

Of course the newly added constant or enum's typemap should be
declared in the appropriate I<xs/maps/*_types.map> files, so the XS
conversion of arguments will be performed correctly. For example
I<apr_read_type> is an APR enum so it's declared in
I<xs/maps/apr_types.map>:

  apr_read_type          | IV

C<IV> is used as a typemap, lSince enum is simply an integer. In more
complex cases the typemap can be different. (META: examples)


=head1 Maintainers

Maintainer is the person(s) you should contact with updates,
corrections and patches.

Stas Bekman E<lt>stas (at) stason.orgE<gt>

=head1 Authors

=over 

=item * Stas Bekman E<lt>stas (at) stason.orgE<gt>

=back

=cut
