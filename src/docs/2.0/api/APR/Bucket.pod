=head1 NAME

APR::Bucket - Perl API for manipulating APR Buckets




=head1 Synopsis

  use APR::Bucket ();
  
  $b1 = APR::Bucket->new("aaa");
  $b2 = APR::Bucket::eos_create($c->bucket_alloc);
  $b3 = APR::Bucket::flush_create($c->bucket_alloc);
  
  $b2->is_eos;
  $b3->is_flush;
  
  $len  = $b1->length;
  $data = $b1->read;
  $type = $b1->type;
  
  $b1->insert_after($b2);
  $b1->insert_before($b3);
  $b1->remove();







=head1 Description

C<APR::Bucket> allows you to create, manipulate and delete APR
buckets.




=head1 API

C<APR::Bucket> provides the following functions and/or methods:





=head2 C<eos_create>

Create an I<EndOfStream> bucket.

  $b = APR::Bucket::eos_create($ba);

=over 4

=item arg1: C<$ba>
( C<L<APR::BucketAlloc object|docs::2.0::api::APR::BucketAlloc>> )

The freelist from which this bucket should be allocated

=item ret: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The new bucket

=item since: 1.99_10

=back

This bucket type indicates that there is no more data coming from down
the filter stack.  All filters should flush any buffered data at this
point.

Example:

  use APR::Bucket ();
  use Apache::Connection ();
  my $ba = $c->bucket_alloc;
  my $eos_b = APR::Bucket::eos_create($ba);





=head2 C<flush_create>

Create a flush bucket.

  $b = APR::Bucket::flush_create($ba);

=over 4

=item arg1: C<$ba>
( C<L<APR::BucketAlloc object|docs::2.0::api::APR::BucketAlloc>> )

The freelist from which this bucket should be allocated

=item ret: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The new bucket

=item since: 1.99_10

=back

This bucket type indicates that filters should flush their data.
There is no guarantee that they will flush it, but this is the best we
can do.






=head2 C<insert_after>

Insert a list of buckets after a specified bucket

  $after_bucket->insert_after($add_bucket);

=over 4

=item obj: C<$after_bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The bucket to insert after

=item arg1: C<$add_bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The buckets to insert. It says buckets, since C<$add_bucket> may have
more buckets attached after itself.

=item ret: no return value

=item since: 1.99_10

=back





=head2 C<insert_before>

Insert a list of buckets before a specified bucket

  $before_bucket->insert_before($add_bucket);

=over 4

=item obj: C<$before_bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The bucket to insert before

=item arg1: C<$add_bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The buckets to insert. It says buckets, since C<$add_bucket> may have
more buckets attached after itself.

=item ret: no return value

=item since: 1.99_10

=back





=head2 C<is_eos>

Determine if a bucket is an EOS bucket

  $ret = $bucket->is_eos();

=over 4

=item obj: C<$bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: C<$ret> ( true/false )

=item since: 1.99_10

=back





=head2 C<is_flush>

Determine if a bucket is a FLUSH bucket

  $ret = $bucket->is_flush();

=over 4

=item obj: C<$bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: C<$ret> ( true/false )

=item since: 1.99_10

=back








=head2 C<length>

Get the length of the data in the bucket.

  $len = $b->length;

=over 4

=item obj: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: C<$len> ( integer )

If the length is unknown, C<$len> value will be -1.

=item since: 1.99_10

=back






=head2 C<new>

Create a new bucket and initialize it with data:

  $nb = APR::Bucket->new($data);
  $nb =          $b->new($data);
  $nb = APR::Bucket->new($data, $offset);
  $nb = APR::Bucket->new($data, $offset, $len);

=over 4

=item obj: C<$b>
( C<L<APR::Bucket object or class|docs::2.0::api::APR::Bucket>> )

=item arg1: C<$data> ( string )

The data to initialize with

=item opt arg2: C<$offset> ( number )

Optional offset inside C<$data>. Default: 0.

=item opt arg3: C<$len> ( number )

Optional partial length to read.

If C<$offset> is specified, then:

  length $buffer - $offset;

will be used. Otherwise the default is to use:

  length $buffer;

=item ret: C<$nb>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

a newly created bucket object

=item since: 1.99_10

=back

Examples:

=over

=item *

Create a new bucket using a whole string:

  use APR::Bucket ();
  my $data = "my data";
  my $b = APR::Bucket->new($data);

now the bucket contains the string I<'my data'>.

=item *

Create a new bucket using a sub-string:

  use APR::Bucket ();
  my $data   = "my data";
  my $offset = 3;
  my $b = APR::Bucket->new($data, $offset);

now the bucket contains the string I<'data'>.

=item *

Create a new bucket not using the whole length and starting from an
offset:

  use APR::Bucket ();
  my $data   = "my data";
  my $offset = 3;
  my $len    = 3;
  my $b = APR::Bucket->new($data, $offset, $len);

now the bucket contains the string I<'dat'>.

=back





=head2 C<read>

Read the data from the bucket.

  $data = $b->read();
  $data = $b->read($block);

=over 4

=item obj: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

The bucket to read from

=item opt arg1: C<$block> ( C<L<APR::Const :read_type
constant|docs::2.0::api::APR::Const/C__read_type_>> )

optional reading mode constant.

By default the read is blocking, via C<L<APR::BLOCK_READ
constant|docs::2.0::api::APR::Const/C_APR__BLOCK_READ_>>.

=item ret: C<$data> ( string )

the read data buffer. The buffer will contain an empty string if no
data was read.

=item since: 1.99_15

=item excpt: C<L<APR::Error|docs::2.0::api::APR::Error>>

=back

Examples:

Blocking read:

  my $data = $b->read();

Non-blocking read:

  use APR::Const -compile 'NONBLOCK_READ';
  my $data = $b->read(APR::NONBLOCK_READ);



=head2 C<remove>

Tell the bucket to remove itself from the bucket brigade it belongs
to.

  $bucket->remove();

=over 4

=item obj: C<$bucket>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: no return value

=item since: 1.99_10

=back

If the bucket is not attached to any bucket brigade then this
operation doesn't do anything.

When the bucket is removed, it's not not destroyed. Usually this is
done in order to move the bucket to another bucket brigade. Or to copy
the data way before destroying the bucket.

Examples:

Assuming that C<$bb1> already exists and filled with buckets, move
every odd bucket number to C<$bb2> and every even to C<$bb3>:

  my $bb2 = APR::Brigade->new($c->pool, $c->bucket_alloc);
  my $bb3 = APR::Brigade->new($c->pool, $c->bucket_alloc);
  my $count = 0;
  while (my $bucket = $bb->first) {
      $count++;
      $bucket->remove;
      $count % 2
          ? $bb2->insert_tail($bucket)
          : $bb3->insert_tail($bucket);
  }






=head2 C<type>

Get the type of the data in the bucket.

  $type = $b->type;

=over 4

=item obj: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: C<$type>
( C<L<APR::BucketType object|docs::2.0::api::APR::BucketType>> )

=item since: 1.99_10

=back

You need to invoke
C<L<APR::BucketType|docs::2.0::api::APR::BucketType>> methods to
access the data.

Example:

Create a flush bucket and read its type's name:

  use APR::Bucket ();
  use APR::BucketType ();
  my $b = APR::Bucket::flush_create($ba);
  my $type = $b->type;
  my $type_name =  $type->name; # FLUSH

The type name will be I<'FLUSH'> in this example.


=head1 Unsupported API

C<APR::Socket> also provides auto-generated perl interface for a few
other methods which aren't tested at the moment and therefore their
API is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the L<the mod_perl development mailing list|maillist::dev>
so we can help eachother take the steps necessary to shift the method
to an officially supported API.





=head2 C<data>

  $data = $b->data;

Gives a C pointer to the address of the data in the bucket. I can't
see what use can be done of it in Perl.

=over 4

=item obj: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: C<$data> ( C pointer )

=item since: subject to change

=back


=head2 C<start>

  $start = $b->start;

It gives the offset to when a new bucket is created with a non-zero
offset value:

  my $b = APR::Bucket->new($data, $offset, $len);

So if the offset was 3. C<$start> will be 3 too.

I fail to see what it can be useful for to the end user (it's mainly
used internally).

=over 4

=item obj: C<$b>
( C<L<APR::Bucket object|docs::2.0::api::APR::Bucket>> )

=item ret: C<$start> ( offset number )

=item since: subject to change

=back


=head1 See Also

L<mod_perl 2.0 documentation|docs::2.0::index>.




=head1 Copyright

mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.




=head1 Authors

L<The mod_perl development team and numerous
contributors|about::contributors::people>.

=cut

