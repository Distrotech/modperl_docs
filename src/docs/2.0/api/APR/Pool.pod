=head1 NAME

APR::Pool - Perl API for XXX




=head1 Synopsis

  use APR::Pool ();

META: to be completed




=head1 Description

META: to be completed




=head1 API

C<APR::Pool> provides the following functions and/or methods:




=head2 C<cleanup_for_exec>

META: Autogenerated - needs to be reviewed/completed

buffers, *don't* wait for subprocesses, and *don't* free any memory. *
Run all of the child_cleanups, so that any unnecessary files are
closed because we are about to exec a new program

=over

=item ret: no return value

=back




=head2 C<cleanup_register>

Register cleanup callbacks to run

  $pool->cleanup_register($callback);
  $pool->cleanup_register($callback, $arg);

=over 4

=item obj: C<$p> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool object to register the cleanup for

=item arg1: C<$callback> (CODE ref or SUB name)

a cleanup callback CODE reference or just a name of the subroutine
(fully qualified unless defined in the current package).

=item opt arg3: C<$arg> (SCALAR)

If this optional argument is passed the C<$callback> function will
receive it as the first and only argument when executed.

To pass more than one argument, use a reference to an array or a hash.

=item ret: no return value

=item since: 1.99_10

=back

Examples:

No arguments, using anon sub as a cleanup callback:

  $r->pool->cleanup_register(sub { warn "running cleanup" });

One or more arguments using a cleanup code reference:

  $r->pool->cleanup_register(\&cleanup, $r);
  $r->pool->cleanup_register(\&cleanup, [$r, $foo]);
  sub cleanup {
      my @args = (@_ && ref $_[0] eq ARRAY) ? @{ +shift } : shift;
      my $r = shift @args;
      warn "cleaning up";
  }


XXX: test that we can do:

  $r->pool->cleanup_register(sub { warn "running cleanup" });
  $r->pool->cleanup_register('foo');

in TestAPR/pool.pm


=head2 C<clear>

META: Autogenerated - needs to be reviewed/completed

Clear all memory in the pool and run all the cleanups. This also destroys all
subpools.

  $p->clear();

=over 4

=item obj: C<$p> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to clear

=item ret: no return value

=back

This does not actually free the memory, it just allows the pool
to re-use this memory for the next allocation.



=head2 C<destroy>

META: Autogenerated - needs to be reviewed/completed

Destroy the pool. This takes similar action as apr_pool_clear() and then
frees all the memory.

  $p->destroy();

=over 4

=item obj: C<$p> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to destroy

=item ret: no return value

=back

This will actually free the memory



=head2 C<is_ancestor>

META: Autogenerated - needs to be reviewed/completed

Determine if pool a is an ancestor of pool b

  $ret = $a->is_ancestor($b);

=over 4

=item obj: C<$a> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to search

=item arg1: C<$b> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to search for

=item ret: C<$ret> (integer)

True if a is an ancestor of b, NULL is considered an ancestor
of all pools.

=back





=head2 C<tag>

META: Autogenerated - needs to be reviewed/completed

Tag a pool (give it a name)

  $pool->tag($tag);

=over 4

=item obj: C<$pool> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to tag

=item arg1: C<$tag> (string)

The tag

=item ret: no return value

=back




=head1 See Also

L<mod_perl 2.0 documentation|docs::2.0::index>.




=head1 Copyright

mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 1.1.




=head1 Authors

L<The mod_perl development team and numerous
contributors|about::contributors::people>.

=cut

